#!/usr/bin/env python3
"""
Utility to quickly determine which Noto fonts are required for a given Unicode string.

It loads `fonts.yaml` (generated by fetch_noto_fonts.py) and builds a bucketed
interval index so lookups are effectively O(1) per codepoint (small constant for
the handful of ranges that overlap a 256-codepoint block).
The built index is cached on disk (pickle) and reused if `fonts.yaml` has not
changed, avoiding rebuilds on subsequent runs.

Example:
    from font_selector import required_fonts
    print(required_fonts("blablabla"))  # -> {"NotoSans", ...}
"""

from __future__ import annotations

import pathlib
import pickle
import sys
from typing import Any, Dict, Iterable, List, Set, Tuple

import yaml

CACHE_VERSION = 3
BLOCK_SHIFT = 8  # 256-codepoint buckets for fast narrowing
BLOCK_SIZE = 1 << BLOCK_SHIFT


class FontIndex:
    """
    Bucketed interval index over Unicode codepoints.
    Each bucket contains a short list of ranges; lookup only walks that list.
    """

    def __init__(self, ranges: Iterable[tuple[int, int, str]]) -> None:
        # buckets: block -> list of (start, end, family)
        self._buckets: Dict[int, List[tuple[int, int, str]]] = {}
        self._family_priority: Dict[str, tuple] = {}
        for start, end, family in ranges:
            start_block = start >> BLOCK_SHIFT
            end_block = end >> BLOCK_SHIFT
            for block in range(start_block, end_block + 1):
                self._buckets.setdefault(block, []).append((start, end, family))

    def fonts_for_codepoint(self, codepoint: int) -> Set[str]:
        bucket = self._buckets.get(codepoint >> BLOCK_SHIFT)
        if not bucket:
            return set()
        return {family for start, end, family in bucket if start <= codepoint <= end}

    def ranges_for_codepoint(self, codepoint: int) -> List[tuple[int, int, str]]:
        bucket = self._buckets.get(codepoint >> BLOCK_SHIFT)
        if not bucket:
            return []
        return [(start, end, family) for start, end, family in bucket if start <= codepoint <= end]

    def to_serialized(self) -> Dict:
        return {
            "version": CACHE_VERSION,
            "block_shift": BLOCK_SHIFT,
            "buckets": {
                block: ranges
                for block, ranges in self._buckets.items()
            },
        }

    @classmethod
    def from_serialized(cls, data: Dict) -> "FontIndex | None":
        if data.get("version") != CACHE_VERSION or data.get("block_shift") != BLOCK_SHIFT:
            return None
        inst = cls([])
        inst._buckets = {int(block): [tuple(r) for r in ranges] for block, ranges in data.get("buckets", {}).items()}
        inst._family_priority = {}
        return inst


def _parse_codepoint(value: Any) -> int:
    """
    Accept legacy string codepoints (e.g. 'U+0041' or '0041'), hex strings like
    '0x0041', or integers.
    """
    if isinstance(value, int):
        return value
    if isinstance(value, str):
        val = value.strip()
        if val.upper().startswith("U+"):
            val = val[2:]
        return int(val, 16 if val.lower().startswith("0x") or all(ch in "0123456789ABCDEFabcdef" for ch in val) else 10)
    raise TypeError(f"Unsupported codepoint value: {value!r}")


def parse_range(range_item: Any, family: str) -> tuple[int, int, str]:
    """
    Parse range representations:
        - 'U+0041' or 'U+0041-U+005A'
        - 'U+0041..U+005A'
        - [0x0041, 0x005A] (new format)
    """
    if isinstance(range_item, str):
        if ".." in range_item:
            start_str, end_str = range_item.split("..", 1)
        elif "-" in range_item:
            start_str, end_str = range_item.split("-", 1)
        else:
            start_str = end_str = range_item
        start = _parse_codepoint(start_str)
        end = _parse_codepoint(end_str)
    elif isinstance(range_item, (list, tuple)):
        if len(range_item) == 1:
            start = end = _parse_codepoint(range_item[0])
        elif len(range_item) == 2:
            start = _parse_codepoint(range_item[0])
            end = _parse_codepoint(range_item[1])
        else:
            raise ValueError(f"Unexpected range list length: {range_item!r}")
    else:
        raise TypeError(f"Unsupported range type: {type(range_item)}")
    start, end = (start, end) if start <= end else (end, start)
    return (start, end, family)


def load_ranges(fonts_yaml: pathlib.Path) -> List[tuple[int, int, str]]:
    data = yaml.safe_load(fonts_yaml.read_text(encoding="utf-8"))
    ranges: List[tuple[int, int, str]] = []
    for entry in data:
        family = entry["family"]
        for r in entry["unicode_ranges"]:
            ranges.append(parse_range(r, family))
    return ranges


def cache_path_for(fonts_yaml: pathlib.Path) -> pathlib.Path:
    return fonts_yaml.with_suffix(".fontindex.pkl")


def load_cached_index(fonts_yaml: pathlib.Path) -> FontIndex | None:
    cache_path = cache_path_for(fonts_yaml)
    if not cache_path.exists():
        return None
    try:
        if cache_path.stat().st_mtime < fonts_yaml.stat().st_mtime:
            return None
        data = pickle.loads(cache_path.read_bytes())
        return FontIndex.from_serialized(data)
    except Exception:
        return None


def save_cached_index(index: FontIndex, fonts_yaml: pathlib.Path) -> None:
    cache_path = cache_path_for(fonts_yaml)
    cache_path.write_bytes(pickle.dumps(index.to_serialized()))


_DEFAULT_INDEX: FontIndex | None = None


def get_index(fonts_yaml: pathlib.Path | None = None) -> FontIndex:
    global _DEFAULT_INDEX
    if fonts_yaml is None:
        fonts_yaml = pathlib.Path(__file__).with_name("fonts.yaml")
    if _DEFAULT_INDEX is None:
        cached = load_cached_index(fonts_yaml)
        if cached:
            _DEFAULT_INDEX = cached
        else:
            _DEFAULT_INDEX = FontIndex(load_ranges(fonts_yaml))
            save_cached_index(_DEFAULT_INDEX, fonts_yaml)
    return _DEFAULT_INDEX


def _ranges_from_codepoints(codepoints: Iterable[int]) -> List[str]:
    cps = sorted(set(codepoints))
    if not cps:
        return []
    ranges: List[str] = []
    start = prev = cps[0]
    for cp in cps[1:]:
        if cp == prev + 1:
            prev = cp
            continue
        # end current
        if start == prev:
            ranges.append(f"U+{start:04X}")
        else:
            ranges.append(f"U+{start:04X}..U+{prev:04X}")
        start = prev = cp
    # flush final
    if start == prev:
        ranges.append(f"U+{start:04X}")
    else:
        ranges.append(f"U+{start:04X}..U+{prev:04X}")
    return ranges


def _font_priority(family: str) -> tuple:
    """
    Prefer base NotoSans first, then other Sans, then Serif, then everything else.
    """
    if family == "NotoSans":
        return (0, family)
    if family.startswith("NotoSans"):
        return (1, family)
    if family.startswith("NotoSerif"):
        return (2, family)
    return (3, family)

def _font_priority_cached(font_index: FontIndex, family: str) -> tuple:
    cached = font_index._family_priority.get(family)
    if cached is not None:
        return cached
    pr = _font_priority(family)
    font_index._family_priority[family] = pr
    return pr


def _assign_fonts(text: str, fonts_yaml: pathlib.Path | None = None) -> tuple[Dict[int, str], Set[int]]:
    """
    Map each codepoint in text to a single chosen font (best priority).
    """
    index = get_index(fonts_yaml)
    assignments: Dict[int, str] = {}
    missing: Set[int] = set()
    for cp in {ord(ch) for ch in text}:
        if cp <= 0x1F:
            continue  # ignore control characters like newline
        fonts = index.fonts_for_codepoint(cp)
        if not fonts:
            missing.add(cp)
            continue
        best = min(fonts, key=lambda f: _font_priority_cached(index, f))
        assignments[cp] = best
    return assignments, missing


def required_fonts(text: str, fonts_yaml: pathlib.Path | None = None) -> Set[str]:
    """
    Return the minimal set of font families (with priority rules) needed to cover `text`.
    """
    assignments, _ = _assign_fonts(text, fonts_yaml)
    return set(assignments.values())


def required_fonts_with_ranges(text: str, fonts_yaml: pathlib.Path | None = None) -> Dict[str, List[str]]:
    """
    Return a mapping font -> list of ranges (within fonts.yaml coverage) that are used by `text`.
    """
    assignments, missing = _assign_fonts(text, fonts_yaml)
    per_font_cps: Dict[str, Set[int]] = {}
    for cp, family in assignments.items():
        per_font_cps.setdefault(family, set()).add(cp)
    if missing:
        per_font_cps["__UNCOVERED__"] = missing
    return {family: _ranges_from_codepoints(cps) for family, cps in per_font_cps.items()}


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="List required Noto fonts for input text.")
    parser.add_argument(
        "text",
        nargs="?",
        help="Input text to analyze (use '-' or omit to read from stdin).",
    )
    parser.add_argument(
        "--fonts-yaml",
        type=pathlib.Path,
        default=None,
        help="Path to fonts.yaml (defaults to fonts.yaml next to this script).",
    )
    parser.add_argument(
        "-r",
        "--ranges",
        action="store_true",
        help="Print fonts with the specific ranges used by the input text.",
    )
    parser.add_argument(
        "--warn-missing",
        action="store_true",
        help="Warn about codepoints not covered by any available font.",
    )
    args = parser.parse_args()
    input_text = args.text
    # Convenience: if first positional looks like a fonts.yaml path and stdin is piped,
    # interpret it as --fonts-yaml and read text from stdin.
    if (
        args.fonts_yaml is None
        and input_text
        and input_text.lower().endswith((".yaml", ".yml"))
        and pathlib.Path(input_text).exists()
        and not sys.stdin.isatty()
    ):
        args.fonts_yaml = pathlib.Path(input_text)
        input_text = None

    if input_text is None or input_text == "-":
        input_text = sys.stdin.read()

    if args.ranges:
        mapping = required_fonts_with_ranges(input_text, fonts_yaml=args.fonts_yaml)
        for family in sorted(mapping.keys()):
            print(family)
            for rng in mapping[family]:
                print(f"  {rng}")
    else:
        fonts = required_fonts(input_text, fonts_yaml=args.fonts_yaml)
        for f in sorted(fonts):
            print(f)

    if args.warn_missing:
        _, missing = _assign_fonts(input_text, fonts_yaml=args.fonts_yaml)
        if missing:
            sys.stderr.write(
                f"Warning: {len(missing)} codepoints not covered by fonts.yaml (e.g. "
                f"{', '.join(f'U+{cp:04X}' for cp in sorted(list(missing))[:10])}"
                f"{'â€¦' if len(missing) > 10 else ''})\n"
            )
